<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Shooter en Primera Persona</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none; /* No bloquear eventos de mouse */
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: red; /* Color de la cruceta */
        }
        #crosshair::before {
            left: 50%;
            top: 0;
            transform: translateX(-50%);
            width: 2px;
            height: 100%;
        }
        #crosshair::after {
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            height: 2px;
            width: 100%;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="crosshair"></div> <!-- Cruceta roja como mira -->
    <script>
        // Escena y cámara
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        // Renderizador
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Fondo
        scene.background = new THREE.Color(0x87CEEB); // Azul cielo

        // Suelo
        const floorTexture = new THREE.TextureLoader().load('https://cdn.pixabay.com/photo/2013/07/12/18/42/tile-73144_960_720.png');
        const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture });
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Enemigos
        const enemies = [];

        function createEnemy() {
            const enemyGroup = new THREE.Group();

            // Material del enemigo
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Verde

            // Torso
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 0.3), bodyMaterial);
            torso.position.y = 1;
            enemyGroup.add(torso);

            // Cabeza
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 32, 32), bodyMaterial);
            head.position.y = 2;
            enemyGroup.add(head);

            // Ojos
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 16, 16), eyeMaterial);
            leftEye.position.set(-0.1, 2.05, 0.15);
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 16, 16), eyeMaterial);
            rightEye.position.set(0.1, 2.05, 0.15);
            enemyGroup.add(leftEye);
            enemyGroup.add(rightEye);

            // Boca enfadada
            const mouthShape = new THREE.Shape();
            mouthShape.moveTo(-0.1, 0);
            mouthShape.lineTo(0, -0.1);
            mouthShape.lineTo(0.1, 0);
            const mouthGeometry = new THREE.ShapeGeometry(mouthShape);
            const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.rotation.x = -Math.PI / 2;
            mouth.position.y = 1.9;
            enemyGroup.add(mouth);

            // Brazos
            const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), bodyMaterial);
            leftArm.position.set(-0.4, 1, 0);
            leftArm.rotation.z = Math.PI / 4;
            enemyGroup.add(leftArm);

            const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), bodyMaterial);
            rightArm.position.set(0.4, 1, 0);
            rightArm.rotation.z = -Math.PI / 4;
            enemyGroup.add(rightArm);

            // Piernas
            const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1, 0.2), bodyMaterial);
            leftLeg.position.set(-0.15, 0, 0);
            enemyGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1, 0.2), bodyMaterial);
            rightLeg.position.set(0.15, 0, 0);
            enemyGroup.add(rightLeg);

            // Agregar enemigo al array y a la escena
            enemyGroup.userData = { health: 1 };  // Añadimos salud al enemigo
            enemies.push(enemyGroup);
            scene.add(enemyGroup);
            return enemyGroup;
        }

        function spawnEnemy() {
            const enemy = createEnemy();
            enemy.position.set(Math.random() * 20 - 10, 0, Math.random() * -20 - 5);
        }

        // Posición inicial de la cámara
        camera.position.set(0, 1.6, 0);

        // Movimiento de la cámara
        const keyboard = {};
        document.addEventListener('keydown', (event) => {
            keyboard[event.code] = true;
        });
        document.addEventListener('keyup', (event) => {
            keyboard[event.code] = false;
        });

        function moveCamera() {
            const speed = 0.1;
            const direction = new THREE.Vector3();
            if (keyboard['KeyW']) {
                camera.getWorldDirection(direction);
                camera.position.addScaledVector(direction, speed);
            }
            if (keyboard['KeyS']) {
                camera.getWorldDirection(direction);
                camera.position.addScaledVector(direction, -speed);
            }
            if (keyboard['KeyA']) {
                camera.getWorldDirection(direction);
                direction.cross(camera.up);
                camera.position.addScaledVector(direction, -speed);
            }
            if (keyboard['KeyD']) {
                camera.getWorldDirection(direction);
                direction.cross(camera.up);
                camera.position.addScaledVector(direction, speed);
            }
        }

        // Disparar proyectiles
        const bullets = [];

        function shoot() {
            const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(camera.position);
            bullets.push(bullet);
            scene.add(bullet);
            const bulletDirection = new THREE.Vector3();
            camera.getWorldDirection(bulletDirection);
            bullet.userData = { direction: bulletDirection.clone() };
        }

        // Evento de disparo
        document.addEventListener('mousedown', (event) => {
            if (event.button === 0) { // Clic izquierdo
                shoot();
            }
        });

        // Colisiones
        function checkCollisions() {
            bullets.forEach((bullet, bulletIndex) => {
                enemies.forEach((enemy, enemyIndex) => {
                    const enemyPosition = new THREE.Vector3();
                    enemyPosition.setFromMatrixPosition(enemy.matrixWorld);

                    // Revisar colisión con el torso
                    const distanceToTorso = bullet.position.distanceTo(enemyPosition);
                    const headPosition = new THREE.Vector3();
                    enemy.children[1].getWorldPosition(headPosition);  // Obtener la posición de la cabeza
                    const distanceToHead = bullet.position.distanceTo(headPosition);  // Distancia a la cabeza

                    if (distanceToTorso < 1.5 || distanceToHead < 0.5) { // Aumentada la hitbox de torso y cabeza
                        // Eliminar bala y enemigo
                        scene.remove(bullet);
                        bullets.splice(bulletIndex, 1);

                        scene.remove(enemy);
                        enemies.splice(enemyIndex, 1);
                    }
                });
            });
        }

        // Animación
        function animate() {
            requestAnimationFrame(animate);
            moveCamera();
            checkCollisions();

            // Mover balas
            bullets.forEach((bullet, index) => {
                bullet.position.add(bullet.userData.direction.clone().multiplyScalar(0.5));
                if (bullet.position.length() > 1000) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                }
            });

            renderer.render(scene, camera);
        }

        // Generar enemigos
        setInterval(spawnEnemy, 2000);
        animate();

        // Control del ratón
        let isMouseLocked = false;
        document.body.addEventListener('click', () => {
            if (!isMouseLocked) {
                document.body.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isMouseLocked = document.pointerLockElement === document.body;
        });

        // Ajuste de sensibilidad
        const sensitivity = 0.001; // Sensibilidad ajustada

        document.addEventListener('mousemove', (event) => {
            if (isMouseLocked) {
                camera.rotation.y -= event.movementX * sensitivity;
                camera.rotation.x -= event.movementY * sensitivity;
            }
        });

    </script>
</body>
</html>


























